use ast::*;
use syntax::Token;
use lexer;

#[LALR]
#[recursive_ascent] grammar<'input>;

pub Block: Box<Expr> = {
    <v:(<Expr> Semicolon)+> <e:Expr?> => Box::new(Expr::Block(v, match e {
        None => Box::new(Expr::Type(Type::Null)),
        Some(e) => e,
    })),
    Expr,
};

Expr: Box<Expr> = {
    ExprAss,
};

ExprAss: Box<Expr> = {
    ExprEquality,
    <v:Id> <o:AssOp> <e:ExprEquality> => Box::new(Expr::BinOp(Box::new(Expr::Type(Type::Id(v))), o, e)),
    Index AssOp ExprEquality => Box::new(Expr::BinOp(<>)),
};

BinOpTier<Op, NextTier>: Box<Expr> = {
    NextTier,
    BinOpTier<Op, NextTier> Op NextTier => Box::new(Expr::BinOp(<>)),
};

ExprEquality = BinOpTier<EqOp, ExprPlusMinus>;
ExprPlusMinus = BinOpTier<SumOp, ExprMulDiv>;
ExprMulDiv = BinOpTier<ProdOp, ExprPrefix>;

ExprPrefix: Box<Expr> = {
    ExprAtom,
    UnOp ExprAtom => Box::new(Expr::UnOp(<>)),
};

ExprAtom: Box<Expr> = {
    Lit,
    Index,
    ExprControl,
    ExprSpread,
    Args => Box::new(Expr::Args(<>)),
    Null => Box::new(Expr::Type(Type::Null)),
    paren,
    scope,
};

paren: Box<Expr> = {
   Lparen <Block> Rparen,
};

scope: Box<Expr> = {
    Lbrace <Block> Rbrace => Box::new(Expr::Scope(<>)),
};

Lit: Box<Expr> = {
    Id => Box::new(Expr::Type(Type::Id(<>))),
    Integer => Box::new(Expr::Type(Type::Number(<>))),
    Float => Box::new(Expr::Type(Type::Float(<>))),
    Bool => Box::new(Expr::Type(Type::Bool(<>))),
    String => Box::new(Expr::Type(Type::String(<>))),
    Array => Box::new(Expr::Type(Type::Array(<>))),
};

Index: Box<Expr> = {
    <i:Id> Lbrack <e:Expr> Rbrack => Box::new(Expr::Index(Box::new(Expr::Type(Type::Id(i))),e)),
    <a:Array> Lbrack <e:Expr> Rbrack => Box::new(Expr::Index(Box::new(Expr::Type(Type::Array(a))), e)),
    <ForA> Lbrack <Expr> Rbrack => Box::new(Expr::Index(<>)),
    <paren> Lbrack <Expr> Rbrack => Box::new(Expr::Index(<>)),
    <scope> Lbrack <Expr> Rbrack => Box::new(Expr::Index(<>)),
};

Id: String = {
    TokId => <>.to_owned(),
};

Integer: i64 = {
    TokInteger => <>.parse::<i64>().unwrap(),
};

Float: f64 = {
    TokFloat => <>.parse::<f64>().unwrap(),
};

Bool: bool = {
    TokBool => <> == "true",
};

String: String = {
    TokString => <>.to_owned(),
};

ExprControl: Box<Expr> = {
    ExprIf,
    ExprWhile,
    ExprFor,
};

ExprIf: Box<Expr> = {
    If <Expr> <scope> => Box::new(Expr::If(<>, Box::new(Expr::Scope(Box::new(Expr::Type(Type::Null)))))),
    If <Expr> <scope> Else <scopeOrIf> => Box::new(Expr::If(<>)),
};

scopeOrIf: Box<Expr> = {
    scope,
    ExprIf,
};

ExprWhile: Box<Expr> = {
    While <Expr> <scope> => Box::new(Expr::While(<>)),
};

ExprFor: Box<Expr> = {
    For <ExprForArgs> <scope> => Box::new(Expr::For(<>)),
    ForA,
};

ForA: Box<Expr> = {
    For Lbrack Rbrack <ExprForArgs> <scope> => Box::new(Expr::ForA(<>)),
};

ExprForArgs: Box<Expr> = {
    Lparen <i:Id?> Comma <j:Id?> Comma <f:Expr> Range <t:Expr>  <s:(Colon <Expr>)?> Rparen => Box::new(
        Expr::Args(vec!(
            Box::new(Expr::Type(match i {
                None => Type::Null,
                Some(i) => Type::Id(i),
            })),
            Box::new(Expr::Type(match j {
                None => Type::Null,
                Some(j) => Type::Id(j),
            })),
            Box::new(Expr::Range(f, t, match s {
                None => Box::new(Expr::Type(Type::Number(1))),
                Some(e) => e,
            }))
        ))
    ),
    Lparen <j:Id?> Comma <f:Expr> Range <t:Expr>  <s:(Colon <Expr>)?> Rparen => Box::new(
        Expr::Args(vec!(
            Box::new(Expr::Type(match j {
                None => Type::Null,
                Some(j) => Type::Id(j),
            })),
            Box::new(Expr::Range(f, t, match s {
                None => Box::new(Expr::Type(Type::Number(1))),
                Some(e) => e,
            }))
        ))
    ),
    Lparen <f:Expr> Range <t:Expr>  <s:(Colon <Expr>)?> Rparen => Box::new(
        Expr::Args(vec!(
            Box::new(Expr::Range(f, t, match s {
                None => Box::new(Expr::Type(Type::Number(1))),
                Some(e) => e,
            }))
        ))
    ),
};

ExprSpread: Box<Expr> = {
};

Args = {
    Lparen <Separated<Comma>> Rparen,
};

Array = {
    Lbrack Rbrack => vec!(),
    Lbrack <Expr> Rbrack => vec!(<>),
    Lbrack <Separated<Comma>> Rbrack,
};

Separated<S>: Vec<Box<Expr>> = {
    <v:(<Expr> S)+> <e:Expr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        },
    },
};

UnOp: UnOpCode = {
    Minus       => UnOpCode::Neg,
    Not         => UnOpCode::Not,
    Len         => UnOpCode::Len,
};

EqOp: BinOpCode = {
    Equiv       => BinOpCode::Equ,
    NotEquiv    => BinOpCode::Neq,
    Less        => BinOpCode::Lt,
    LessEqual   => BinOpCode::LEt,
    Greater     => BinOpCode::Gt,
    GreatEqual  => BinOpCode::GEt,
};

AssOp: BinOpCode = {
    Equal       => BinOpCode::Ass,
    MinusEq     => BinOpCode::SubEq,
    PlusEq      => BinOpCode::AddEq,
    MultEq      => BinOpCode::MulEq,
    DivideEq    => BinOpCode::DivEq,
    ModEq       => BinOpCode::ModEq,
};

SumOp: BinOpCode = {
    Plus        => BinOpCode::Add,
    Minus       => BinOpCode::Sub,
};

ProdOp: BinOpCode = {
    Mult        => BinOpCode::Mul,
    Divide      => BinOpCode::Div,
    Mod         => BinOpCode::Mod,
};

extern {
    type Location = usize;
    type Error = lexer::LexicalError<'input>;

    enum Token<'input> {
        Null        => Token::Null,
        For         => Token::KeyFor,
        While       => Token::KeyWhile,
        If          => Token::KeyIf,
        Else        => Token::KeyElse,

        Lparen      =>  Token::OpLparen,
        Rparen      =>  Token::OpRparen,
        Lbrace      =>  Token::OpLbrace,
        Rbrace      =>  Token::OpRbrace,
        Lbrack      =>  Token::OpLbrack,
        Rbrack      =>  Token::OpRbrack,
        Minus       =>  Token::OpMinus,
        Plus        =>  Token::OpPlus,
        Divide      =>  Token::OpDivide,
        Mult        =>  Token::OpMult,
        MinusEq     =>  Token::OpMinusEq,
        PlusEq      =>  Token::OpPlusEq,
        DivideEq    =>  Token::OpDivideEq,
        MultEq      =>  Token::OpMultEq,
        Mod         =>  Token::OpMod,
        ModEq       =>  Token::OpModEq,
        Power       =>  Token::OpPower,
        Land        =>  Token::OpLand,
        Lor         =>  Token::OpLor,
        Equal       =>  Token::OpEqual,
        Equiv       =>  Token::OpEquiv,
        NotEquiv    =>  Token::OpNotEquiv,
        Greater     =>  Token::OpGreater,
        Less        =>  Token::OpLess,
        GreatEqual  =>  Token::OpGreatEqual,
        LessEqual   =>  Token::OpLessEqual,
        And         =>  Token::OpAnd,
        Or          =>  Token::OpOr,
        Not         =>  Token::OpNot,
        Comma       =>  Token::OpComma,
        Colon       =>  Token::OpColon,
        Semicolon   =>  Token::OpSemicolon,
        Dot         =>  Token::OpDot,
        Range       =>  Token::OpRange,
        Len         =>  Token::OpLength,

        TokInteger     => Token::Integer(<&'input str>),
        TokFloat       => Token::Float(<&'input str>),
        TokId          => Token::Id(<&'input str>),
        TokString      => Token::String(<&'input str>),
        TokBool        => Token::Bool(<&'input str>),
    }
}
